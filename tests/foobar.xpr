(*
type TPoint = record str: string; x,y: Int32; end;
type TPointArray = array of string;

func main();
  var a: TPointArray;
  var b: TPointArray;
  a.SetLen(10501);
  var h := a.High();
  var tmp: string;
  tmp.SetLen(10);
  
  for(var j:=0; j <= h; j+=1) do
    a[j] := tmp;
  end
  
  b := a;
end;

for (var i:=0; i<=10; i:=i+1) do
  print i;
  main();
end;
*)

type TMyFunc = func(Pointer);
type PInt64 = ^Int64;
type PByte = ^Int8;

func test(p: PInt64);
  print p^;
end;

func CallTo(f: TMyFunc);
  var test: Int64 = 100;
  var ptr: Pointer = addr(test);
  print ptr;
  
  print PByte(ptr)[0];
  print PByte(ptr)[1];
  print PByte(ptr)[2];
  print PByte(ptr)[3];
  print '--------------------'
  
  var arr: array of Int32;
  arr.setlen(5);
  arr[0] := 100;
  arr[1] := 200;
  print arr[0]
  print arr[1]
  
  var pint: ^Int32 = addr(arr[0])
  print pint[0]
  print pint[1]
  

  if(f != nil)
    f(ptr);
end;

CallTo(test);


(*
 This test will not work for long, it does [-2] which is very illegal,
 even more so since we now do refcounting, and this is a array of array.
 
 It's just a misc test for me.
*)
(*
func RefCountTest()
  var arr: array of array of Int64;
  arr.SetLen(1);
  arr[0].SetLen(3);
  arr[0][0] := 123;

  print arr[-2]; // Expected: 1 — just one reference to arr

  var alias := arr;
  print arr[-2]; // Expected: 2 — alias now also references arr

  alias := nil;
  print arr[-2]; // Expected: 1 — alias released, back to single reference

  var holder: array of array of Int64;
  holder := arr;
  
  var refcount: Int64 = arr[-2]; 
  print 'Expected: 2, Got: ' + refcount.ToStr()

  arr := nil;
  print holder[-2]; // Expected: 1 — arr released, holder still holds one reference

  holder := nil;
  // At this point, refcount would hit 0 and memory is freed.
  // Accessing [-2] now is undefined, so we don't print here.
end;

RefCountTest();

var i:=0;
repeat
  i := i + 1;
  if(i % 10 != 0) continue;
  print i
  
  if(i > 50) then
    break;
  end;
until(i = 100);
*)