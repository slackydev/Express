(*
type TBar = record 
  myBar: int64 
end

type TFoo = record 
  x,y: int
  bar: TBar 
end

var a: TFoo

a.x := 13
a.y := 3
a.bar.mybar := a.y * 500 + a.x

print a.x
print a.y  
print a.bar.myBar


// ------------------------------------------------
var x: Int32 = 10;
var y: Int32 = 11;

if ((x = 11 or x = 12 or x = 13 or x = 10) and (y = 11)) then
  print 9999999
end;

if (x = 10 and x = 10 and y = 11 and x = 10) then
  print 'This is True'
elif (x = 10) then
  print 'impossible'
else
  print 'NO!'
end;

// ------------------------------------------------
var z:Int64 = 10;
Inc(z);
print(z);


// ------------------------------------------------

type EImpossible = class(Exception) end;

try
  1 / 0
except on E: ENativeError do
  print 'Error: '+E.Message
except on E: EImpossible do
  print 'E2r: '+E.Message
end;

print 'We are still good!'

*)
(*
generic swap(ref x,y: type)
  (x,y) := [y,x]
end;

var x: int = 1;
var y: int = 2;
swap(x,y)
print x
print y


*)
print 100 * 100

generic array of numeric.sum(): numeric
  print '-------'
  var t: typeof(self[0])
  t := self[0];
  print t
  return self[1]
end;

var data: array of float = [99.0,98.0,97.0]
print data.sum(): float

var test: array of int = [1,2,3]

var i:float = (100.0 * test.sum():int)
print i


(*
generic myFunc(x:array; y:array): int
  Result := x*2;
end;

generic myFunc(x:array; y:type; z:class): int
  Result := x*2;
end;

generic array.sum(): int
  Result := x*2;
end;



// ONLY result requires explicit (unless it can be resolved automatic by LHS)
print myFunc(10)
*)
